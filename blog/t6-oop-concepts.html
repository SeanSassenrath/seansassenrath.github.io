<!DOCTYPE html>
<head>
  <title>Blog</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="../stylesheets/default.css">
  <link rel="stylesheet" type="text/css" href="../stylesheets/blog-stylesheet.css">
  <link rel="stylesheet" href="src/tomorrow_night.css">
  <link href='http://fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
</head>

<body>
   <div id="container">
      <ul>
        <li><a class="nav" href="../index.html">HOME</a></li>
        <li><a class="nav" href="../projects/projects-menu.html">PROJECTS</a></li>
        <li><a class="currentPage" href="../blog/blog-menu.html">BLOG</a></li>
        <li><a class="nav" href="../about/about.html">ABOUT</a></li>
        <li><a class="nav" href="?">CONTACT</a></li>
      </ul>
      <img src="http://seabeaches.com/images/demo/slide01.jpg"/>
      <div class="blogPost">
        <h1>INHERITANCE vs COMPOSITION</h1>
        <h3>3.12.2015</h3>
        <p>
        When it comes to OOP design, there are a few ways to look at class structure and how classes communicate with each in your program. This post will be looking specifically at Inheritance and Composition structures.
        </p>
        <h2 class="blogPost">INHERITANCE</h2>
        <p>
          Just as it sounds, inheritance allows a class to take on the features of a parent class. In the examples below I’ll be going over how a child class can use functionality from it’s parent class, how a child class can override functionality from it’s parent class, and lastly how it can use both it’s own functionality and the parent classes functionality under at the same time. For this example read “Father” as the parent class and “Son” as the child class.
        </p>
        <p>
          First let’s take a look at what happens when the child class “Son”, with no functionality of its own, inherits features from it’s parent class “Father”
        </p>
    <pre class="prettyprint">
    class Father

      def print
        puts "I’m the Father!"
      end
    end

    class Son < Father
    end

    tim = Father.new
    bobby = Son.new

    tim.print # => “I’m the Father!”
    bobby.print # => “I’m the Father!”
    </pre>
        <p>
          As you can see, we didn’t define any functionality in the Son class, but since we inherited the function from the Father class, the Son class returned “I’m the Father!”
        </p>
        <p>
          Now let’s say we wanted son.print to print “I’m the Son” instead. We can override the Father class functionality by creating the same method in the Son class.
        </p>
    <pre class="prettyprint">
    class Father

      def print
        puts "I’m the Father!!"
      end
    end

    class Son < Father

      def print
        puts “I’m the Son!”
    end

    tim = Father.new
    bobby = Son.new

    tim.print # => “I’m the Father!”
    bobby.print # => “I’m the Son!”

    </pre>
        <p>
          There you have it. Creating an identical “print” method in the Son class overrides the Father class “print” method, thus returning “I’m the Son!”
        </p>
        <p>
          Let’s switch gears. What if wanted to run functionality under the same method for both classes? After overriding “print” in the Son class, can we then run the “print” from the Father class as well? Turns out you can with the handy “super” call. The “super” call will return the result of the method in the Father class.
        </p>
    <pre class="prettyprint">
    class Father

      def print
        puts "I’m the Father!!"
      end
    end

    class Son < Father

      def print
        puts “I’m the Son!”
        super
        puts “Yes, you’re my Father.”
    end

    tim = Father.new
    bobby = Son.new

    tim.print # => “I’m the Father!”
    bobby.print # => “I’m the Son!”
            # => “I’m the Father!”
            # => “Yes, you’re my Father.”
    </pre>
        <p>
          When we call “super” in the example above, it runs the Father class “print” method giving us the result of that method in between the results of our Son class “print” method.
        </p>
        <p>
          Inheritance seems straightforward enough in these examples, but I’m weary of how complicated and entwined classes will become if they depend on this inherited relationships. What if, in a big enough program you accidently override a method from the parent class? It seems like it’d take a while to find the error and fix it. My own personal feeling is that this system is too rigid. It doesn’t have the flexibility of creating classes that work WITH each other, instead it all depends on who the classes are work for.
        </p>
        <h2 class="blogPost">COMPOSITION</h2>
        <p>
          Unlike inheritance, class composition offers a flexible structure of OOP design. Instead of relying on what class belongs to which superclass, you can have the classes interact with in a horizontal structure.
        </p>
        <p>
          Be careful! For this example I’m going to use the same class names as I did above, but take a minute to recognize that there isn’t any inheritance involved.
        </p>
    <pre class="prettyprint">
    class Father

      def print_father
        puts "I’m the Father!!"
      end
    end

    class Son

      def initialize
        @father = Father.new
      end

      def print_son
        puts “I’m the Son!”
      end

      def print_father
        @father.print_father
      end

    end

    bobby = Son.new

    bobby.print_son # => “I’m the Son!”
    bobby.print_father # => “I’m the Father!”
  </pre>
        <p>
          In this example we connect the Father class to the Son class through the Son class initialize method by assigning it to the instance variable @father. By doing this we aren’t inheriting anything from the Father class, but we do have access to its methods if we’d like to use them. Cool, right?!
        </p>
        <h2 class="blogPost">CONCLUSION</h2>
        <p>
          The structure and design of OOP ultimately comes down to the person writing the code. I’m sure there are some people who love inheritance and there are those who love composition. So far, I find myself in the composition camp. I feel like a plug-n-play, flexible, horizontal design is more my style than a layered, connected, vertical design.
        </p>
        <a id="blogNav" href="c6-stereotype-threat.html"><h3 id="blogNav">NEXT POST</h3></a>
        <a id="blogNav" href="c5-feedback.html"><h3 id="blogNav">PREVIOUS POST</h3></a>
      </div>
    <ul class="bottomNavBlog">
        <li><a class="nav" href="https://www.linkedin.com/in/seansassenrath/en">LINKED IN</a></li>
        <li><a class="nav" href="https://github.com/SeanSassenrath">GITHUB</a></li>
        <li><a class="nav" href="https://www.twitter.com/seansassenrath">TWITTER</a></li>
        <li><a class="nav" href="https://www.facebook.com/sassenrath">FACEBOOK</a></li>
        <li><a class="backMain" href="blog-menu.html">BACK TO BLOGS</a></li>
        <li class="contactBottomBackMain"><a class="nav" href="?">CONTACT</a></li>
    </ul>
    <h5>Sean Sassenrath - Web Dev 2015</h5>
  </div>
  <script src="src/prettify.js"></script>
  <script>
    prettyPrint();
  </script>
</body>
</html>

